import { securityLogger, SecurityEventType, SecurityEventSeverity } from './security-logging';
import { auditTrail, AuditActionType } from './audit-trail';

// Vulnerability severity levels
export enum VulnerabilitySeverity {
  CRITICAL = 'CRITICAL',
  HIGH = 'HIGH',
  MEDIUM = 'MEDIUM',
  LOW = 'LOW',
  INFO = 'INFO',
}

// Vulnerability types
export enum VulnerabilityType {
  XSS = 'XSS',
  CSRF = 'CSRF',
  SQL_INJECTION = 'SQL_INJECTION',
  AUTHENTICATION = 'AUTHENTICATION',
  AUTHORIZATION = 'AUTHORIZATION',
  CRYPTO = 'CRYPTO',
  DEPENDENCY = 'DEPENDENCY',
  CONFIGURATION = 'CONFIGURATION',
  DATA_EXPOSURE = 'DATA_EXPOSURE',
  INJECTION = 'INJECTION',
  INSECURE_COMMUNICATION = 'INSECURE_COMMUNICATION',
  BUSINESS_LOGIC = 'BUSINESS_LOGIC',
}

// Vulnerability finding
export interface VulnerabilityFinding {
  id: string;
  type: VulnerabilityType;
  severity: VulnerabilitySeverity;
  title: string;
  description: string;
  location: string;
  evidence?: string;
  recommendation: string;
  cwe?: string; // Common Weakness Enumeration
  cvss?: number; // Common Vulnerability Scoring System
  references?: string[];
  detectedAt: number;
  status: 'open' | 'acknowledged' | 'fixed' | 'false_positive';
}

// Security scan configuration
export interface SecurityScanConfig {
  enableXSSScanning: boolean;
  enableCSRFScanning: boolean;
  enableAuthScanning: boolean;
  enableCryptoScanning: boolean;
  enableConfigScanning: boolean;
  enableDependencyScanning: boolean;
  enableDataExposureScanning: boolean;
  scanTimeout: number;
  maxFindings: number;
}

const DEFAULT_SCAN_CONFIG: SecurityScanConfig = {
  enableXSSScanning: true,
  enableCSRFScanning: true,
  enableAuthScanning: true,
  enableCryptoScanning: true,
  enableConfigScanning: true,
  enableDependencyScanning: true,
  enableDataExposureScanning: true,
  scanTimeout: 30000, // 30 seconds
  maxFindings: 100,
};

// Vulnerability scanner
export class VulnerabilityScanner {
  private static instance: VulnerabilityScanner;
  private config: SecurityScanConfig;
  private findings: Map<string, VulnerabilityFinding> = new Map();
  
  private constructor(config: SecurityScanConfig = DEFAULT_SCAN_CONFIG) {
    this.config = config;
  }
  
  static getInstance(config?: SecurityScanConfig): VulnerabilityScanner {
    if (!VulnerabilityScanner.instance) {
      VulnerabilityScanner.instance = new VulnerabilityScanner(config);
    }
    return VulnerabilityScanner.instance;
  }
  
  // Run comprehensive security scan
  async runSecurityScan(): Promise<VulnerabilityFinding[]> {
    console.log('[VulnerabilityScanner] Starting security scan...');
    
    const findings: VulnerabilityFinding[] = [];
    const startTime = Date.now();
    
    try {
      // XSS vulnerability scanning
      if (this.config.enableXSSScanning) {
        findings.push(...await this.scanForXSS());
      }
      
      // CSRF vulnerability scanning
      if (this.config.enableCSRFScanning) {
        findings.push(...await this.scanForCSRF());
      }
      
      // Authentication vulnerabilities
      if (this.config.enableAuthScanning) {
        findings.push(...await this.scanAuthentication());
      }
      
      // Cryptographic vulnerabilities
      if (this.config.enableCryptoScanning) {
        findings.push(...await this.scanCryptography());
      }
      
      // Configuration vulnerabilities
      if (this.config.enableConfigScanning) {
        findings.push(...await this.scanConfiguration());
      }
      
      // Data exposure vulnerabilities
      if (this.config.enableDataExposureScanning) {
        findings.push(...await this.scanDataExposure());
      }
      
      // Dependency vulnerabilities
      if (this.config.enableDependencyScanning) {
        findings.push(...await this.scanDependencies());
      }
      
      // Store findings
      findings.forEach(finding => this.findings.set(finding.id, finding));
      
      const duration = Date.now() - startTime;
      
      securityLogger.log(
        SecurityEventType.AUDIT_LOG_ACCESS,
        SecurityEventSeverity.MEDIUM,
        {
          action: 'Security scan completed',
          duration,
          findingsCount: findings.length,
          criticalCount: findings.filter(f => f.severity === VulnerabilitySeverity.CRITICAL).length,
          highCount: findings.filter(f => f.severity === VulnerabilitySeverity.HIGH).length,
        }
      );
      
      auditTrail.log(
        AuditActionType.BULK_OPERATION,
        'security',
        { action: 'Vulnerability scan', findingsCount: findings.length, duration }
      );
      
      return findings.slice(0, this.config.maxFindings);
      
    } catch (error) {
      securityLogger.log(
        SecurityEventType.ERROR,
        SecurityEventSeverity.HIGH,
        { action: 'Security scan failed', error: (error as Error).message }
      );
      
      throw error;
    }
  }
  
  // Scan for XSS vulnerabilities
  private async scanForXSS(): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for dangerous innerHTML usage
    if (typeof document !== 'undefined') {
      const scriptElements = document.querySelectorAll('script');
      scriptElements.forEach((script, index) => {
        if (script.innerHTML.includes('innerHTML') && 
            !script.innerHTML.includes('sanitize') && 
            !script.innerHTML.includes('DOMPurify')) {
          findings.push({
            id: `xss-innerHTML-${index}`,
            type: VulnerabilityType.XSS,
            severity: VulnerabilitySeverity.HIGH,
            title: 'Potential XSS via innerHTML',
            description: 'Direct innerHTML usage without sanitization detected',
            location: `Script element ${index}`,
            recommendation: 'Use DOMPurify.sanitize() or textContent instead of innerHTML',
            cwe: 'CWE-79',
            cvss: 7.5,
            detectedAt: Date.now(),
            status: 'open',
          });
        }
      });
    }
    
    // Check for eval() usage
    const evalUsagePattern = /eval\s*\(/g;
    if (typeof window !== 'undefined' && window.location.href) {
      // This is a simplified check - real implementation would scan source code
      findings.push({
        id: 'xss-eval-check',
        type: VulnerabilityType.XSS,
        severity: VulnerabilitySeverity.INFO,
        title: 'eval() Usage Check',
        description: 'Checking for dangerous eval() usage in application code',
        location: 'Application code',
        recommendation: 'Avoid using eval() with user input. Use JSON.parse() for JSON data.',
        cwe: 'CWE-95',
        detectedAt: Date.now(),
        status: 'open',
      });
    }
    
    return findings;
  }
  
  // Scan for CSRF vulnerabilities
  private async scanForCSRF(): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for CSRF protection
    const hasCSRFToken = typeof document !== 'undefined' && 
      (document.querySelector('meta[name="csrf-token"]') || 
       document.querySelector('input[name="_token"]') ||
       document.querySelector('input[name="csrf_token"]'));
    
    if (!hasCSRFToken) {
      findings.push({
        id: 'csrf-missing-token',
        type: VulnerabilityType.CSRF,
        severity: VulnerabilitySeverity.MEDIUM,
        title: 'Missing CSRF Protection',
        description: 'No CSRF tokens detected in the application',
        location: 'Application forms',
        recommendation: 'Implement CSRF protection using tokens or SameSite cookies',
        cwe: 'CWE-352',
        cvss: 6.1,
        detectedAt: Date.now(),
        status: 'open',
      });
    }
    
    return findings;
  }
  
  // Scan authentication vulnerabilities
  private async scanAuthentication(): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for insecure authentication storage
    if (typeof localStorage !== 'undefined') {
      const authToken = localStorage.getItem('clearhold_auth_token');
      if (authToken && !authToken.includes('encrypted')) {
        findings.push({
          id: 'auth-plaintext-storage',
          type: VulnerabilityType.AUTHENTICATION,
          severity: VulnerabilitySeverity.MEDIUM,
          title: 'Authentication Token in Plain Text',
          description: 'Authentication tokens stored in localStorage without encryption',
          location: 'localStorage',
          recommendation: 'Encrypt sensitive tokens before storing in localStorage',
          cwe: 'CWE-312',
          cvss: 5.3,
          detectedAt: Date.now(),
          status: 'open',
        });
      }
    }
    
    // Check for session management
    if (typeof sessionStorage !== 'undefined') {
      const session = sessionStorage.getItem('clearhold_session');
      if (!session) {
        findings.push({
          id: 'auth-no-session-mgmt',
          type: VulnerabilityType.AUTHENTICATION,
          severity: VulnerabilitySeverity.LOW,
          title: 'No Session Management Detected',
          description: 'Application may lack proper session management',
          location: 'Session storage',
          recommendation: 'Implement secure session management with timeouts',
          cwe: 'CWE-384',
          detectedAt: Date.now(),
          status: 'open',
        });
      }
    }
    
    return findings;
  }
  
  // Scan cryptographic implementations
  private async scanCryptography(): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for weak cryptographic algorithms
    if (typeof window !== 'undefined' && window.crypto) {
      findings.push({
        id: 'crypto-webcrypto-available',
        type: VulnerabilityType.CRYPTO,
        severity: VulnerabilitySeverity.INFO,
        title: 'Web Crypto API Available',
        description: 'Web Crypto API is available and should be used for cryptographic operations',
        location: 'Browser environment',
        recommendation: 'Use Web Crypto API for secure random generation and cryptographic operations',
        detectedAt: Date.now(),
        status: 'open',
      });
    }
    
    // Check for hardcoded secrets (simplified check)
    const commonSecretPatterns = [
      /api[_-]?key/i,
      /secret/i,
      /password/i,
      /private[_-]?key/i,
    ];
    
    // This is a simplified check - real implementation would scan source files
    findings.push({
      id: 'crypto-hardcoded-secrets-check',
      type: VulnerabilityType.CRYPTO,
      severity: VulnerabilitySeverity.INFO,
      title: 'Hardcoded Secrets Check',
      description: 'Checking for potential hardcoded secrets in application',
      location: 'Application code',
      recommendation: 'Use environment variables or secure key management for secrets',
      cwe: 'CWE-798',
      detectedAt: Date.now(),
      status: 'open',
    });
    
    return findings;
  }
  
  // Scan configuration vulnerabilities
  private async scanConfiguration(): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for development mode in production
    if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {
      findings.push({
        id: 'config-dev-mode',
        type: VulnerabilityType.CONFIGURATION,
        severity: VulnerabilitySeverity.MEDIUM,
        title: 'Development Mode Detected',
        description: 'Application is running in development mode',
        location: 'Environment configuration',
        recommendation: 'Ensure production mode is enabled in production environments',
        cwe: 'CWE-489',
        detectedAt: Date.now(),
        status: 'open',
      });
    }
    
    // Check for insecure protocols
    if (typeof window !== 'undefined' && window.location.protocol === 'http:') {
      findings.push({
        id: 'config-insecure-protocol',
        type: VulnerabilityType.INSECURE_COMMUNICATION,
        severity: VulnerabilitySeverity.HIGH,
        title: 'Insecure HTTP Protocol',
        description: 'Application is accessed over insecure HTTP protocol',
        location: 'Protocol configuration',
        recommendation: 'Use HTTPS for all communications',
        cwe: 'CWE-319',
        cvss: 7.5,
        detectedAt: Date.now(),
        status: 'open',
      });
    }
    
    return findings;
  }
  
  // Scan for data exposure vulnerabilities
  private async scanDataExposure(): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for sensitive data in localStorage
    if (typeof localStorage !== 'undefined') {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.includes('password') || key.includes('ssn') || key.includes('card'))) {
          const value = localStorage.getItem(key);
          if (value && !value.startsWith('encrypted_')) {
            findings.push({
              id: `data-exposure-${key}`,
              type: VulnerabilityType.DATA_EXPOSURE,
              severity: VulnerabilitySeverity.HIGH,
              title: 'Sensitive Data in localStorage',
              description: `Sensitive data stored in localStorage: ${key}`,
              location: 'localStorage',
              recommendation: 'Encrypt sensitive data before storing or use secure storage',
              cwe: 'CWE-200',
              cvss: 7.5,
              detectedAt: Date.now(),
              status: 'open',
            });
          }
        }
      }
    }
    
    // Check for console logging in production
    if (typeof console !== 'undefined') {
      findings.push({
        id: 'data-exposure-console-logging',
        type: VulnerabilityType.DATA_EXPOSURE,
        severity: VulnerabilitySeverity.LOW,
        title: 'Console Logging Check',
        description: 'Verify that sensitive data is not logged to console in production',
        location: 'Console output',
        recommendation: 'Remove or disable console logging in production builds',
        cwe: 'CWE-532',
        detectedAt: Date.now(),
        status: 'open',
      });
    }
    
    return findings;
  }
  
  // Scan dependencies for known vulnerabilities
  private async scanDependencies(): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];
    
    // This would typically integrate with npm audit or similar tools
    // For now, we'll create a placeholder finding
    findings.push({
      id: 'dependency-audit-required',
      type: VulnerabilityType.DEPENDENCY,
      severity: VulnerabilitySeverity.INFO,
      title: 'Dependency Security Audit Required',
      description: 'Run npm audit or yarn audit to check for vulnerable dependencies',
      location: 'Package dependencies',
      recommendation: 'Run "npm audit" or "yarn audit" regularly and update vulnerable packages',
      detectedAt: Date.now(),
      status: 'open',
    });
    
    return findings;
  }
  
  // Get all findings
  getAllFindings(): VulnerabilityFinding[] {
    return Array.from(this.findings.values());
  }
  
  // Get findings by severity
  getFindingsBySeverity(severity: VulnerabilitySeverity): VulnerabilityFinding[] {
    return this.getAllFindings().filter(f => f.severity === severity);
  }
  
  // Get findings by type
  getFindingsByType(type: VulnerabilityType): VulnerabilityFinding[] {
    return this.getAllFindings().filter(f => f.type === type);
  }
  
  // Mark finding as fixed
  markFindingAsFixed(findingId: string): boolean {
    const finding = this.findings.get(findingId);
    if (finding) {
      finding.status = 'fixed';
      return true;
    }
    return false;
  }
  
  // Mark finding as false positive
  markFindingAsFalsePositive(findingId: string): boolean {
    const finding = this.findings.get(findingId);
    if (finding) {
      finding.status = 'false_positive';
      return true;
    }
    return false;
  }
  
  // Generate security report
  generateSecurityReport(): {
    summary: {
      totalFindings: number;
      criticalFindings: number;
      highFindings: number;
      mediumFindings: number;
      lowFindings: number;
      infoFindings: number;
    };
    findings: VulnerabilityFinding[];
    recommendations: string[];
  } {
    const findings = this.getAllFindings();
    
    const summary = {
      totalFindings: findings.length,
      criticalFindings: findings.filter(f => f.severity === VulnerabilitySeverity.CRITICAL).length,
      highFindings: findings.filter(f => f.severity === VulnerabilitySeverity.HIGH).length,
      mediumFindings: findings.filter(f => f.severity === VulnerabilitySeverity.MEDIUM).length,
      lowFindings: findings.filter(f => f.severity === VulnerabilitySeverity.LOW).length,
      infoFindings: findings.filter(f => f.severity === VulnerabilitySeverity.INFO).length,
    };
    
    const recommendations = [
      'Prioritize fixing critical and high severity vulnerabilities',
      'Implement regular security scanning in CI/CD pipeline',
      'Conduct security code reviews for all changes',
      'Keep dependencies updated and monitor for vulnerabilities',
      'Use automated security testing tools',
    ];
    
    return { summary, findings, recommendations };
  }
}

// Dependency vulnerability monitor
export class DependencyMonitor {
  private static instance: DependencyMonitor;
  private lastScanTime: number = 0;
  private scanInterval: number = 24 * 60 * 60 * 1000; // 24 hours
  
  private constructor() {}
  
  static getInstance(): DependencyMonitor {
    if (!DependencyMonitor.instance) {
      DependencyMonitor.instance = new DependencyMonitor();
    }
    return DependencyMonitor.instance;
  }
  
  // Check if scan is needed
  shouldScan(): boolean {
    return Date.now() - this.lastScanTime > this.scanInterval;
  }
  
  // Run dependency audit
  async runDependencyAudit(): Promise<{
    vulnerabilities: Array<{
      package: string;
      version: string;
      severity: string;
      advisory: string;
      patched?: string;
    }>;
    total: number;
  }> {
    // In a real implementation, this would integrate with npm audit API
    // or use tools like Snyk, WhiteSource, etc.
    
    this.lastScanTime = Date.now();
    
    // Mock implementation
    return {
      vulnerabilities: [],
      total: 0,
    };
  }
  
  // Monitor for new vulnerabilities
  startMonitoring(): void {
    setInterval(async () => {
      if (this.shouldScan()) {
        try {
          const results = await this.runDependencyAudit();
          
          if (results.total > 0) {
            securityLogger.log(
              SecurityEventType.SECURITY_CONFIG_CHANGED,
              SecurityEventSeverity.HIGH,
              {
                action: 'Dependency vulnerabilities detected',
                vulnerabilityCount: results.total,
              }
            );
          }
        } catch (error) {
          securityLogger.log(
            SecurityEventType.ERROR,
            SecurityEventSeverity.MEDIUM,
            { action: 'Dependency scan failed', error: (error as Error).message }
          );
        }
      }
    }, 60 * 60 * 1000); // Check every hour
  }
}

// Export singletons
export const vulnerabilityScanner = VulnerabilityScanner.getInstance();
export const dependencyMonitor = DependencyMonitor.getInstance();